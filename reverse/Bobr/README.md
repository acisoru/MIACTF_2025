# Bobr | Hard | Reverse

## Информация

Are you bobr enough to solve this task?
Формат флага - miactf{}


## Выдать участинкам

[public/main](public/main)

## Описание

Запакованная с помощью upx rop-виртуалка, которая немного преобразует флаг на асме, возвращает строку в Си и там ксорит и сравнивает с эталонной.

## Решение

Открываем бинарь main. Видим в hex-редакторе строку UPX и понимаем, что бинарь запакован с помощью UPX 5.0 (можно также понять с помощью Detect it easy). 
С помощью команды `upx -d main` распаковываем. Смотрим декомпилированный код.
Видим, что в массив складываются по очереди ассемблерные функции или данные, а в конце return. Более того, мы знаем, что значения из массива хранятся в стеке. Значит, при вызове return функции в стеке будут выполняться по очереди.
Восстанавливаем ассемблерный код, можно сравнить с [исходником](src/main.c). 
В [исходнике](src/main.c) описано, что делает каждый блок ассемблерного кода. Если коротко: мапит память, выводит запрос пароля, считывает пароль из 32 символов по адресу 0x1000000. Далее с каждым блоком из 8 символов: разворачивает, делает циклический сдвиг и что-то прибавляет. Потом открывает файл `bobr.bin`, считывает оттуда 32 байта по адресу 0x1002000 и закрывает файл. 
Проблема в том, что файл `bobr.bin` генерируется скриптом `gen.pyc`. Но нужен пароль.
Декомпилируем `gen.pyc`, например, с помощью [сайта](https://pylingual.io) или pycdc/...
Видим, что полученный пароль кодируется в base64 и сравнивается с эталоном. С помощью, например, [cyberchef](https://gchq.github.io/CyberChef/) декодируем эталонную строку s из base64 в строку, это и есть пароль.
Вводим пароль в `gen.pyc` и получаем файл `bobr.bin`. Возвращаемся к бинарю.
Бинарь считанные байты ксорит все 4 блока по 8 байт по адресу 0x1000000 и по адресу 0x1002000. Получились новые 32 байта по адресу 0x1002000. Каждый из 4 блоков по 8 байт разворачивает. В конце вызывает функцию finish и передаёт в неё 4 блока по 8 символов.
Функция finish объединяет 4 блока по 8 символов, ксорит их с чем-то и получает строку.
Далее сравнивает полученную строку с эталоном.

## Флаг

miactf{S1d1m_s_B0br0m_za_St0l0m}

